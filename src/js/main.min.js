(() => {
  // packages/djaker-hakim/linkion/src/js/core-script.js
  var coreTrait = {
    list: [],
    components: /* @__PURE__ */ new Map(),
    isReady: false,
    // event dispatcher
    emit(event, detail = {}) {
      document.dispatchEvent(new CustomEvent(event, { detail }));
    },
    // Main init method
    init(root = document) {
      this.emit("linkion:before-init");
      const elements = root.querySelectorAll("[lnkn-data]");
      elements.forEach((el) => this.initComponent(el));
      this.isReady = true;
      this.emit("linkion:ready");
    },
    // Initialize one component
    initComponent(el) {
      const data = el.getAttribute("lnkn-data");
      if (!data) return;
      const component = JSON.parse(data);
      this.add(component);
      this.addTemplate(component, el.outerHTML);
      this.emit("linkion:component:init", { el, component });
    },
    // Initialize on DOM ready
    start() {
      this.emit("linkion:init");
      this.init();
      this.initAssets();
      this.initScripts();
    },
    add(props) {
      if (!props._id) {
        this.has(props.componentName) ? "" : this.list.push(props);
        return;
      }
      if (!this.getComponentByProp("_id", props._id)) {
        this.components.set(props._id, props);
        this.list.push(props);
      }
      return;
    },
    get(name) {
      if (this.components.has(name)) return this.components.get(name);
      let comp = {};
      if ((comp = this.getComponentByProp("componentName", name)) || (comp = this.getComponentByProp("ref", name))) return comp;
      return null;
    },
    getComponentByProp(prop, value) {
      return this.list.find((component) => component[prop] == value);
    },
    getComponentsByProp(prop, value) {
      return this.list.filter((component) => component[prop] == value);
    },
    getCurrentComponent(el) {
      if (!el || el.nodeType !== 1) return null;
      const root = el.closest("[lnkn-id]");
      if (root) return this.getComponentByProp("_id", root.getAttribute("lnkn-id"));
      return null;
    },
    removeComponentByProp(prop, value) {
      this.list = this.list.filter((component) => component[prop] != value);
    },
    has(name) {
      return this.components.has(name) && (this.getComponentByProp("componentName", name) || this.getComponentByProp("ref", name));
    },
    cleanInactiveComponents() {
      const components = document.querySelectorAll("[lnkn-id]");
      let ids = [];
      for (let comp of components) {
        ids.push(comp.getAttribute("lnkn-id"));
      }
      for (let key of this.components.keys()) {
        if (key && !ids.includes(key)) {
          this.components.delete(key);
          this.removeComponentByProp("_id", key);
        }
      }
    }
  };

  // packages/djaker-hakim/linkion/src/js/ApiCalls/apiTools.js
  var apiToolsTrait = {
    token: null,
    url: "/linkion/connection",
    getToken() {
      this.token = !this.token ? document.querySelector("[data-token]").getAttribute("data-token") : "";
      return this.token;
    },
    async fetch(train) {
      this.token = document.querySelector("[data-token]").getAttribute("data-token");
      try {
        const response = await fetch(this.url, {
          method: "POST",
          headers: {
            "X-CSRF-TOKEN": this.token,
            "Accept": "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(train)
        });
        if (!response.ok) {
          const data = await response.text();
          return this.displayError(data);
        }
        return await response.json();
      } catch (e) {
        return e;
      }
    },
    updateComponent(props) {
      const component = this.get(props.componentName);
      Object.keys(props).forEach((key) => {
        component[key] = props[key];
      });
    },
    displayError(error) {
      const container = document.createElement("section");
      const div = document.createElement("div");
      container.style.width = "100vw";
      container.style.height = "100vh";
      container.style.padding = "8px";
      container.style.display = "flex";
      container.style.justifyContent = "center";
      container.style.position = "absolute";
      container.style.top = 0;
      container.style.zIndex = 999;
      div.style.width = "95%";
      div.style.backgroundColor = "white";
      div.innerHTML = error;
      container.append(div);
      document.querySelector("body").append(container);
    }
  };

  // packages/djaker-hakim/linkion/src/js/ApiCalls/apiLoad.js
  var apiLoadTrait = {
    async load(name, args = {}) {
      if (this.has(name)) return Promise.resolve(this.get(name));
      const train = {
        props: { componentName: name, ...args },
        methods: {},
        actions: {}
      };
      try {
        const data = await this.fetch(train);
        this.add(data.props);
        return this.get(name);
      } catch (e) {
        return e;
      }
    }
  };

  // packages/djaker-hakim/linkion/src/js/ApiCalls/apiCall.js
  var apiCallTrait = {
    async call(name, method, args = []) {
      const component = this.get(name);
      const train = {
        props: component,
        methods: {
          method,
          args
        },
        actions: {}
      };
      try {
        const data = await this.fetch(train);
        this.updateComponent(data.props);
        if (!component.componentCached || data.template) {
          this.renderTemplate(component, data.template);
        }
        return data.result;
      } catch (e) {
        console.error(e);
        return e;
      }
    }
  };

  // packages/djaker-hakim/linkion/src/js/ApiCalls/apiUpload.js
  var apiUploadTrait = {
    progress: null,
    loading: false,
    fileUpload(name, prop, files) {
      const xhr = new XMLHttpRequest();
      const formData = new FormData();
      const component = this.get(name);
      formData.append("actions", "upload");
      formData.append("_token", this.getToken());
      formData.append("props", JSON.stringify({
        componentName: component ? component.componentName : name,
        prop
      }));
      if (files instanceof FileList) {
        for (let i = 0; i < files.length; i++) {
          formData.append(prop + "[]", files[i]);
        }
      } else {
        formData.append(prop, files);
      }
      xhr.open("POST", this.url);
      xhr.setRequestHeader("X-CSRF-TOKEN", this.getToken());
      xhr.onloadstart = () => {
        this.loading = true;
      };
      xhr.upload.addEventListener("progress", (e) => {
        if (e.lengthComputable) {
          this.progress = Math.round(e.loaded / e.total * 100);
          this.emit(
            "upload-progress",
            {
              progress: this.progress,
              component: component ? component : { componentName: name }
            }
          );
        }
      });
      xhr.onload = () => {
        if (xhr.status == 200) {
          obj = JSON.parse(xhr.responseText);
          this.updateComponent(obj.props);
          console.log(this.get(obj.props.componentName));
        } else {
          this.displayError(xhr.responseText);
        }
        this.loading = false;
      };
      xhr.onerror = () => {
        console.error("error");
      };
      xhr.send(formData);
    }
  };

  // packages/djaker-hakim/linkion/src/js/Render/renderTools.js
  var renderTrait = {
    templates: /* @__PURE__ */ new Map(),
    addTemplate(component, template) {
      if (!this.hasTemplate(component.componentName)) {
        this.templates.set(component.componentName, template);
      }
    },
    getTemplate(name) {
      return this.templates.get(name);
    },
    hasTemplate(name) {
      return this.templates.has(name);
    },
    async render(name, args = {}, el) {
      const component = this.get(name);
      if (component && this.hasTemplate(name)) {
        return Promise.resolve(
          this.renderTemplate(component, this.getTemplate(name), el)
        );
      }
      const train = {
        props: component ? component : { componentName: name, ...args },
        methods: {},
        actions: "render"
      };
      try {
        const data = await this.fetch(train);
        component ? this.updateComponent(data.props) : this.add(data.props);
        this.renderTemplate(this.get(name), data.template, el);
        return data.result;
      } catch (e) {
        console.error(e);
        return e;
      }
    },
    renderTemplate(component, template, el = null) {
      if (el) return this.renderComponent(component, template, el);
      if (document.querySelector(`[lnkn-id=${component._id}]`)) return this.reRenderComponent(component, template);
      return this.addTemplate(component, template);
    },
    renderComponent(component, template, el) {
      let oldTemplate = el;
      let newTemplate = oldTemplate.cloneNode(true);
      newTemplate.innerHTML = template;
      this.init(newTemplate);
      let comps = newTemplate.querySelectorAll("[lnkn-id]");
      let ids = [];
      for (let comp of comps) {
        ids.push(comp.getAttribute("lnkn-id"));
      }
      ids = ids.filter((id) => id != component._id);
      this.setAssets(newTemplate);
      oldTemplate.outerHTML = newTemplate.innerHTML;
      for (let id of ids) {
        this.setScripts(id, newTemplate);
      }
      this.setScripts(component._id, newTemplate);
      this.cleanInactiveComponents();
      this.cleanScripts();
    },
    reRenderComponent(component, template) {
      let oldTemplate = document.querySelector(`[lnkn-id=${component._id}]`);
      let newTemplate = document.createElement("div");
      newTemplate.innerHTML = template;
      this.init(newTemplate);
      let comps = newTemplate.querySelectorAll("[lnkn-id]");
      let ids = [];
      for (let comp of comps) {
        ids.push(comp.getAttribute("lnkn-id"));
      }
      ids = ids.filter((id) => id != component._id);
      this.setAssets(newTemplate, true);
      oldTemplate.outerHTML = newTemplate.innerHTML;
      if (!ids.length == 0) {
        for (let id of ids) {
          this.setScripts(id, newTemplate);
        }
      }
      this.setScripts(component._id, newTemplate);
      this.cleanInactiveComponents();
      this.cleanScripts();
      return;
    }
  };

  // packages/djaker-hakim/linkion/src/js/Render/assetsAndScripts.js
  var assetsAndScriptsTrait = {
    assets: {},
    head: null,
    body: null,
    getHead() {
      if (!this.head) this.head = document.querySelector("head");
      return this.head;
    },
    getBody() {
      if (!this.body) this.body = document.querySelector("body");
      return this.body;
    },
    assetsHas(name) {
      return Object.keys(this.assets).includes(name);
    },
    assetsGet(name) {
      return this.assets[name];
    },
    assetsSet(name, value) {
      this.assets[name] = value;
    },
    assetsAdd(name, asset) {
      this.assets[name].push(asset);
    },
    componentHasAsset(name, asset) {
      if (this.assetsHas(name)) {
        const assets = this.assetsGet(name);
        let status = false;
        for (let compAsset of assets) {
          status |= compAsset.innerText == asset.innerText;
        }
        return status;
      }
      return false;
    },
    initAssets(root = document) {
      this.setAssets(root, true);
    },
    initScripts() {
      this.getHead().append(...document.querySelectorAll(`script[lnkn-script]`));
    },
    setAssets(root, active = false) {
      const assets = root.querySelectorAll("[lnkn-asset]");
      for (let asset of assets) {
        let key = asset.getAttribute("lnkn-asset");
        if (this.assetsHas(key)) {
          if (this.componentHasAsset(key, asset)) {
            asset.remove();
          } else {
            active ? this.getHead().append(asset) : [asset] = this.setScriptTags([asset], this.getHead(), false);
            this.assetsAdd(key, asset);
          }
        } else {
          active ? this.getHead().append(asset) : [asset] = this.setScriptTags([asset], this.getHead(), false);
          this.assetsSet(key, [asset]);
        }
      }
    },
    setScripts(id, template) {
      const oldScripts = document.querySelectorAll(`script[lnkn-script=${id}]`);
      const scripts = template.querySelectorAll(`script[lnkn-script=${id}]`);
      for (let script of oldScripts) {
        script.remove();
      }
      this.setScriptTags(scripts, this.getHead());
      return template;
    },
    cleanScripts() {
      const scripts = document.querySelectorAll("script[lnkn-script]");
      for (let script of scripts) {
        this.components.has(script.getAttribute("lnkn-script")) ? "" : script.remove();
      }
    },
    setScriptTags(scripts, el, att) {
      let newScripts = [];
      for (let script of scripts) {
        const newScript = document.createElement("script");
        this.copyElement(script, newScript, att);
        script.remove();
        el.append(newScript);
        newScripts.push(newScript);
      }
      return newScripts;
    },
    copyElement(source, target, script = true) {
      for (let attr of source.attributes) {
        target.setAttribute(attr.name, attr.value);
      }
      if (script) {
        target.textContent = `(() => {${source.textContent}})();`;
      } else {
        target.textContent = source.textContent;
      }
    }
  };

  // packages/djaker-hakim/linkion/src/js/Linkion.js
  var Linkion = class {
    static traits = [
      coreTrait,
      apiCallTrait,
      apiToolsTrait,
      apiLoadTrait,
      apiUploadTrait,
      renderTrait,
      assetsAndScriptsTrait
    ];
    static register(...traits) {
      this.constructor.traits.push(...traits);
    }
    constructor() {
      Object.assign(this, ...this.constructor.traits);
    }
  };

  // packages/djaker-hakim/linkion/src/js/linkionProxy/componentProxy.js
  function componentProxy(component, linkion) {
    return new Proxy(component, {
      get(target, method) {
        if (method in target) return target[method];
        if (method === "then") return void 0;
        let ref = component.ref ? component.ref : component.componentName;
        if (method === "render") {
          return (...args) => linkion.render(ref, ...args);
        }
        if (method === "upload") {
          return (...args) => linkion.fileUpload(ref, ...args);
        }
        return (...args) => linkion.call(ref, method, args);
      }
    });
  }

  // packages/djaker-hakim/linkion/src/js/linkionProxy/lnknProxy.js
  var toDotted = (name) => name.replace(/([a-z])([A-Z])/g, "$1.$2").toLowerCase();
  function linkionProxy(linkion) {
    return new Proxy(linkion, {
      get(target, component) {
        if (component in target) return target[component];
        if (component === "then") return void 0;
        if (target.get(component)) {
          return componentProxy(target.get(component), target);
        }
        return new Proxy({}, {
          get(_, method) {
            if (method === "render") {
              return (...args) => target.render(toDotted(component), ...args);
            }
          }
        });
      }
    });
  }

  // packages/djaker-hakim/linkion/src/js/main.js
  window.linkion = linkionProxy(new Linkion());
  queueMicrotask(() => {
    window.linkion.start();
  });
})();
